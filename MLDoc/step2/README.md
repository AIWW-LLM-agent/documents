# Документация для 2 раздела агента

конвертация валидного вопроса в дата-стор

## Контракт на входе

Для корректной отработки, на входе хотелось бы иметь определенные данные в том или ином 
виде. Я буду создавать систему из расчета, что я могу ими оперировать. 

Объект на входе должен иметь следующие параметры:

- natural language question: оригинальный, валидированный запрос
- semantic question id: индекс вопроса из какой-либо системы ключ-значение, хранящей 
  параметризованные вопросы. Если вопрос новый, но валидный - None
- semantic question parametrized: параметризованная версия вопроса, которая могла 
  находиться по предыдущему индексу. Если вопрос новый - параметризует предшествующий 
  агент. Пример: `Какой гибрид $crop_name$ показал наибольшую урожайность в сезоне $year$?`
- extracted parameters: словарь со всеми необходимыми параметрами, извлеченными из 
  предыдущего вопроса. Должен содержать все параметры, которые могут вызываться в `semantic question parametrized`

Итого, этот агент ожидает на входе получить параметризованный ответ с валидными 
параметрами

## Контракт на выходе

На выходе этот раздел агента предоставляет следующие данные:

- datastore name: имя виртуальной таблицы в базе данных, необходимой на следующем шаге

## Архитектура решения

### Cache path

Так как заранее известны схемы части вопросов, можно воспользоваться семаническим 
кэшированием (вопрос+параметры). Сейчас я реализую это как массив с параметризованными 
функциями. В случае, если на вход приходит уже известная схема вопросов, данные пойдут 
по этому пути:

1) Извлечь процедуру, хранимую для этого вопроса
2) Подставить параметры
3) Корректно обработать взаимодействие с БД и создать виртуальную таблицу

**Псевдокод**

``` 
if context[question_id]:
    data_store = prosedures[question_id].apply(context[params])
    data_store.save()
    if ok?:
        return data_store.name
```

Таким образом, тул отработает без обращения к LLM. 

[//]: # (TODO: дописать new question и нарисовать диаграммы + код)